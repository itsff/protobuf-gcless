package com.google.code.proto.memless;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MemlessGenerator {

	private static final String HEADER = "// Generated by the protocol buffer memless compiler.  DO NOT EDIT!\n";

	public static void main(String[] args) {
		if (args.length < 2) {
			System.out.println("invalid usage. Expected: <output-path> <proto-files>");
			return;
		}

		File output = new File(args[0]);
		if (!output.exists()) {
			System.out.println("<output-path> doesnt exist");
			return;
		}
		if (!output.isDirectory()) {
			System.out.println("<output-path> is not a directory");
			return;
		}

		for (int i = 1; i < args.length; i++) {
			try {
				process(output, args[i]);
			} catch (Exception e) {
				System.out.println("unable to process: " + args[i]);
				e.printStackTrace();
			}
		}
	}

	private static void process(File output, String filename) throws Exception {
		String file = loadFile(filename);
		MemlessParser parser = new MemlessParser();
		parser.process(file);
		String packageName = parser.getPackageName();
		if (packageName != null) {
			output = createPackage(output, packageName);
		}

		BufferedWriter w = null;
		if (parser.getOuterClassName() != null) {
			w = new BufferedWriter(new FileWriter(new File(output, parser.getOuterClassName() + ".java")));
			w.append(HEADER);
			appendPackage(w, parser.getPackageName());
			appendImport(w, "java.io.IOException");
			appendImport(w, "com.google.code.proto.memless.ProtobufOutputStream");
			w.append("public final class ");
			w.append(parser.getOuterClassName());
			w.append(" {\nprivate ");
			w.append(parser.getOuterClassName());
			w.append("() {}\n");
		}

		for (ProtobufEnum curEnum : parser.getEnums()) {
			String curEnumData = generateEnum(curEnum);
			if (parser.getOuterClassName() != null) {
				w.append(curEnumData);
			} else {
				BufferedWriter enumWriter = new BufferedWriter(new FileWriter(new File(output, curEnum.getName()
						+ ".java")));
				appendPackage(enumWriter, parser.getPackageName());
				enumWriter.append(curEnumData);
				enumWriter.flush();
				enumWriter.close();
			}
		}

		for (ProtobufMessage curMessage : parser.getMessages()) {
			String curMessageData = generateMessage(curMessage, parser.getPackageName(), parser.getOuterClassName());
			String serializerData = generateSerializer(curMessage, parser.getPackageName(), parser.getOuterClassName());
			if (parser.getOuterClassName() != null) {
				w.append(curMessageData);
				w.append(serializerData);
			} else {
				BufferedWriter messageWriter = new BufferedWriter(new FileWriter(new File(output, curMessage.getName()
						+ ".java")));
				appendPackage(messageWriter, parser.getPackageName());
				messageWriter.append(curMessageData);
				messageWriter.flush();
				messageWriter.close();
				messageWriter = new BufferedWriter(new FileWriter(new File(output, curMessage.getName() + "Serializer"
						+ ".java")));
				appendPackage(messageWriter, parser.getPackageName());
				appendImport(w, "java.io.IOException");
				appendImport(w, "com.google.code.proto.memless.ProtobufOutputStream");
				messageWriter.append(serializerData);
				messageWriter.flush();
				messageWriter.close();
			}
		}

		if (parser.getOuterClassName() != null) {
			w.append("}\n\n");
			w.flush();
			w.close();
		}

	}

	private static String generateSerializer(ProtobufMessage curMessage, String packageName, String outerClassName) {
		StringBuilder result = new StringBuilder();
		if (outerClassName == null) {
			result.append("public final class ");
		} else {
			result.append("public static class ");
		}
		String fullMessageType = constructTypeRaw(curMessage.getName(), packageName, outerClassName, curMessage);
		result.append(curMessage.getName());
		result.append("Serializer {\npublic static byte[] serialize(");
		result.append(fullMessageType);
		result.append(" message) {\n");
		if (curMessage.getFields().isEmpty()) {
			result.append("return new byte[0]; \n}\n");
		} else {
			result.append("try {\nassertInitialized(message);\nint totalSize = 0;\n");
			for (ProtobufField curField : curMessage.getFields()) {
				if (getJavaType(curField) == null) {
					result.append("byte[] ");
					result.append(convertNameToJavabean(curField));
					result.append("Buffer = null;\n");
					result.append("if (message.has");
					result.append(convertNameToJavabean(curField));
					result.append("()) {\n");
					result.append(convertNameToJavabean(curField));
					result.append("Buffer = ");
					result.append(curField.getType());
					result.append("Serializer.serialize(message.get");
					result.append(convertNameToJavabean(curField));
					result.append("());\ntotalSize += ");
					result.append(convertNameToJavabean(curField));
					result.append("Buffer.length;\n");
					result.append("}\n");
					continue;
				}
				String computeFielValue = "ProtobufOutputStream.compute" + convertNameToJavabean(curField.getType()) + "Size(" + curField.getTag() + ", message.get" + convertNameToJavabean(curField) + "());\n";
				if (curField.getNature().equals("repeated")) {
					result.append("int ");
					result.append(convertNameToJavabean(curField));
					result.append("Size = 0;\n");
					result.append("if (message.has");
					result.append(convertNameToJavabean(curField));
					result.append("()) {\n");
					//TODO create byte[] only once for string
					if( curField.getType().equals("bytes") ) {
						result.append(convertNameToJavabean(curField));
						result.append("Size = ");
						result.append("message.get");
						result.append(convertNameToJavabean(curField));
						result.append("().length;\n");
					} else {
						result.append("for(int i=0;i<message.get");
						result.append(convertNameToJavabean(curField));
						result.append("().size();i++) {\n");
						result.append(convertNameToJavabean(curField));
						result.append("Size += ");
						result.append("ProtobufOutputStream.compute" + convertNameToJavabean(curField.getType()) + "Size(" + curField.getTag() + ", message.get" + convertNameToJavabean(curField) + "().get(i));\n");
						result.append("}\n");
					}
					result.append("totalSize += ");
					result.append(convertNameToJavabean(curField));
					result.append("Size;\n}\n");
				} else {
					result.append("if (message.has");
					result.append(convertNameToJavabean(curField));
					result.append("()) {\n");
					result.append("totalSize += ");
					if( curField.getType().equals("bytes") ) {
						result.append("message.get");
						result.append(convertNameToJavabean(curField));
						result.append("().length;\n");
					} else {
						result.append(computeFielValue);
					}
					result.append("}\n");
				}
			}
			result.append("final byte[] result = new byte[totalSize];\nint position = 0;\n");
			for (ProtobufField curField : curMessage.getFields()) {
				result.append("if (message.has");
				String javaBeanName = convertNameToJavabean(curField);
				result.append(javaBeanName);
//			      if (getPackedInt32List().size() > 0) {
//			          output.writeRawVarint32(722);
//			          output.writeRawVarint32(packedInt32MemoizedSerializedSize);
//			        }
//			        for (int element : getPackedInt32List()) {
//			          output.writeInt32NoTag(element);
//			        }
				result.append("()) {\n");
				if (curField.getNature().equals("repeated")) {
					result.append("if (message.get");
					result.append(convertNameToJavabean(curField));
					if( curField.getType().equals("bytes") ) {
						result.append("().length != 0) {\nposition = ProtobufOutputStream.writeRawVarint32(");
					} else {
						result.append("().size() > 0 ) {\nposition = ProtobufOutputStream.writeRawVarint32(");
					}
					result.append(curField.getTag());
					result.append(", result, position);\nposition = ProtobufOutputStream.writeRawVarint32(");
					result.append(convertNameToJavabean(curField));
					if (getJavaType(curField) == null) {
						result.append("Buffer.length, result, position);\n}\n");
					} else {
						result.append("Size, result, position);\n}\n");
					}
					//TODO for cycle
					result.append("}\n");
				} else {
					result.append("position = ProtobufOutputStream.write");
					if (getJavaType(curField) != null) {
						result.append(convertNameToJavabean(curField.getType()));
						result.append("(");
						result.append(curField.getTag());
						result.append(", message.get");
						result.append(convertNameToJavabean(curField));
						result.append("(), result, position);\n}\n");
					} else {
						result.append("Bytes");
						result.append("(");
						result.append(curField.getTag());
						result.append(", ");
						result.append(convertNameToJavabean(curField));
						result.append("Buffer, result, position);\n}\n");
					}
				}
			}
			result.append("ProtobufOutputStream.checkNoSpaceLeft(result, position);\nreturn result;\n} catch (IOException e) {\n	throw new RuntimeException(\"Serializing to a byte array threw an IOException \" + \"(should never happen).\", e);}\n}\n");
			result.append("private static void assertInitialized(");
			result.append(fullMessageType);
			result.append(" message) {\n");
			for (ProtobufField curField : curMessage.getFields()) {
				if (curField.getNature().equals("required")) {
					result.append("if( !message.has");
					result.append(convertNameToJavabean(curField));
					result.append("()) {\nthrow new IllegalArgumentException(\"Required field not initialized: ");
					result.append(curField.getName());
					result.append("\");\n}\n");
				}
			}
			result.append("}\n");
		}
		for (ProtobufMessage innerMessage : curMessage.getNestedMessages()) {
			String newOuterClassname = "";
			if (outerClassName != null) {
				newOuterClassname = outerClassName + ".";
			}
			newOuterClassname += curMessage.getName();
			result.append(generateSerializer(innerMessage, packageName, newOuterClassname));
		}
//		for (ProtobufEnum curEnum : curMessage.getEnums()) {
//			result.append(generateSerializer(curEnum));
//		}
		result.append("}\n");
		return result.toString();
	}

	private static String generateMessage(ProtobufMessage curMessage, String packageName, String outerClassName) {
		StringBuilder result = new StringBuilder();
		result.append("public interface ");
		result.append(curMessage.getName());
		result.append(" {\n");
		for (ProtobufField curField : curMessage.getFields()) {
			String javaBeanName = convertNameToJavabean(curField);
			if (curField.isDeprecated()) {
				result.append("@Deprecated\n");
			}
			result.append("boolean has");
			result.append(javaBeanName);
			result.append("();\n");
			String javaType = constructType(curField, packageName, outerClassName, curMessage);
			if (curField.isDeprecated()) {
				result.append("@Deprecated\n");
			}
			result.append(javaType);
			result.append(" get");
			result.append(javaBeanName);
			result.append("();\n");
			if (curField.isDeprecated()) {
				result.append("@Deprecated\n");
			}
			result.append("void set");
			result.append(javaBeanName);
			result.append("(");
			result.append(javaType);
			result.append(" ");
			result.append(curField.getName());
			result.append(");\n");
		}
		for (ProtobufMessage innerMessage : curMessage.getNestedMessages()) {
			String newOuterClassname = "";
			if (outerClassName != null) {
				newOuterClassname = outerClassName + ".";
			}
			newOuterClassname += curMessage.getName();
			result.append(generateMessage(innerMessage, packageName, newOuterClassname));
		}
		for (ProtobufEnum curEnum : curMessage.getEnums()) {
			result.append(generateEnum(curEnum));
		}
		result.append("}\n");
		return result.toString();
	}

	private static String generateEnum(ProtobufEnum pEnum) {
		StringBuilder result = new StringBuilder();
		result.append("public enum ");
		result.append(pEnum.getName());
		result.append(" {\n");
		Map<Long, EnumValue> added = new HashMap<Long, EnumValue>();
		List<EnumValue> duplicate = new ArrayList<EnumValue>();
		for (EnumValue curValue : pEnum.getValues()) {
			if (added.containsKey(curValue.getId())) {
				duplicate.add(curValue);
				continue;
			}
			result.append(curValue.getName());
			result.append("(");
			result.append(curValue.getId());
			result.append("),\n");
			added.put(curValue.getId(), curValue);
		}

		for (EnumValue curDuplicate : duplicate) {
			result.append(";\npublic static final ");
			result.append(pEnum.getName());
			result.append(" ");
			result.append(curDuplicate.getName());
			result.append(" = ");
			result.append(added.get(curDuplicate.getId()).getName());
		}

		result.append(";\npublic static ");
		result.append(pEnum.getName());
		result.append(" valueOf(int value) {\nswitch (value) {\n");
		for (EnumValue curValue : pEnum.getValues()) {
			if (duplicate.contains(curValue)) {
				continue;
			}
			result.append("case ");
			result.append(curValue.getId());
			result.append(": return ");
			result.append(curValue.getName());
			result.append(";\n");
		}
		result.append("default: return null;\n}\n}\nprivate ");
		result.append(pEnum.getName());
		result.append("(int value) {\nthis.value = value;\n}\nprivate int value;\npublic int getValue() {\nreturn value;\n}\n}\n\n");
		return result.toString();
	}

	private static String getFullyClarifiedName(ProtobufMessage parentMessage, String nestedType, String outerClassName) {
		for (ProtobufMessage curMessage : parentMessage.getNestedMessages()) {
			if (curMessage.getName().equals(nestedType)) {
				return outerClassName + "." + nestedType;
			}
			String sub = getFullyClarifiedName(curMessage, nestedType, outerClassName + "." + curMessage.getName());
			if (sub != null) {
				return sub;
			}
		}
		for (ProtobufEnum curEnum : parentMessage.getEnums()) {
			if (curEnum.getName().equals(nestedType)) {
				return outerClassName + "." + nestedType;
			}
		}
		return null;
	}

	private static void appendPackage(BufferedWriter w, String packageName) throws Exception {
		if (packageName != null) {
			w.append("package ");
			w.append(packageName);
			w.append(";\n\n");
		}
	}

	private static void appendImport(BufferedWriter w, String imp) throws Exception {
		w.append("import ");
		w.append(imp);
		w.append(";\n");
	}

	private static String constructType(ProtobufField curField, String packageName, String outerClassName,
			ProtobufMessage curMessage) {
		StringBuilder result = new StringBuilder();
		String javaType = getJavaType(curField);
		if (javaType == null) {
			javaType = "";
			if (packageName != null) {
				javaType = packageName + ".";
			}
			if (outerClassName != null) {
				javaType += outerClassName + ".";
			}
			javaType += curMessage.getName();
			String depth = getFullyClarifiedName(curMessage, curField.getType(), javaType);
			if (depth != null) {
				javaType = depth;
			}
			//FIXME import message name is consumed. *_*
		}
		if (curField.getNature().equals("repeated") && !curField.getType().equals("bytes")) {
			result.append("java.util.List<");
		}
		result.append(javaType);
		if (curField.getNature().equals("repeated") && !curField.getType().equals("bytes")) {
			result.append(">");
		}
		return result.toString();
	}

	private static String constructTypeRaw(String messageType, String packageName, String outerClassName,
			ProtobufMessage curMessage) {
		String javaType = "";
		if (packageName != null) {
			javaType = packageName + ".";
		}
		if (outerClassName != null) {
			javaType += outerClassName + ".";
		}
		javaType += curMessage.getName();
		String depth = getFullyClarifiedName(curMessage, messageType, javaType);
		if (depth != null) {
			javaType = depth;
		}
		return javaType;
		//FIXME import message name is consumed. *_*
	}

	private static String getJavaType(ProtobufField curField) {
		if (curField.getType().equals("int32") || curField.getType().equals("uint32")
				|| curField.getType().equals("sint32") || curField.getType().equals("fixed32")
				|| curField.getType().equals("sfixed32")) {
			if (curField.getNature().equals("repeated")) {
				return "Integer";
			} else {
				return "int";
			}
		}
		if (curField.getType().equals("int64") || curField.getType().equals("uint64")
				|| curField.getType().equals("sint64") || curField.getType().equals("fixed64")
				|| curField.getType().equals("sfixed64")) {
			if (curField.getNature().equals("repeated")) {
				return "Long";
			} else {
				return "long";
			}
		}
		if (curField.getType().equals("double")) {
			if (curField.getNature().equals("repeated")) {
				return "Double";
			} else {
				return "double";
			}
		}
		if (curField.getType().equals("bool")) {
			if (curField.getNature().equals("repeated")) {
				return "Boolean";
			} else {
				return "boolean";
			}
		}
		if (curField.getType().equals("string")) {
			return "String";
		}
		if (curField.getType().equals("bytes")) {
			return "byte[]";
		}
		if (curField.getType().equals("float")) {
			if (curField.getNature().equals("repeated")) {
				return "Float";
			} else {
				return "float";
			}
		}
		return null;
	}

	private static String convertNameToJavabean(ProtobufField curField) {
		return convertNameToJavabean(curField.getName());
	}

	private static String convertNameToJavabean(String str) {
		StringBuilder result = new StringBuilder();
		result.append(Character.toUpperCase(str.charAt(0)));
		if (str.length() > 1) {
			result.append(str.substring(1));
		}
		return result.toString();
	}

//    FOREIGN_FOO(0, 4),
//    FOREIGN_BAR(1, 5),
//    FOREIGN_BAZ(2, 6),
//    ;
//    
//    
//    public final int getNumber() { return value; }
//    
//    public static ForeignEnum valueOf(int value) {
//      switch (value) {
//        case 4: return FOREIGN_FOO;
//        case 5: return FOREIGN_BAR;
//        case 6: return FOREIGN_BAZ;
//        default: return null;
//      }
//    }	

//    private ForeignEnum(int index, int value) {
//        this.index = index;
//        this.value = value;
//      }

	private static File createPackage(File parent, String packageName) {
		String[] paths = packageName.split("\\.");
		File curDirectory = parent;
		for (String curPath : paths) {
			File curDirPath = new File(curDirectory, curPath);
			if (!curDirPath.exists() || !curDirPath.isDirectory()) {
				curDirPath.mkdir();
			}
			curDirectory = curDirPath;
		}
		return curDirectory;
	}

	private static String loadFile(String filename) throws Exception {
		//rude, but didnt find usages of double slashes in-between some valid identifiers
		Pattern COMMENT = Pattern.compile("//(.*)");
		StringBuilder result = new StringBuilder();
		BufferedReader r = null;
		try {
			r = new BufferedReader(new FileReader(filename));
			String curLine = null;
			while ((curLine = r.readLine()) != null) {
				if (curLine.startsWith("//")) {
					continue;
				}
				Matcher m = COMMENT.matcher(curLine);
				if (m.find()) {
					curLine = m.replaceAll("");
				}
				result.append(curLine);
				result.append("\n");
			}
		} finally {
			if (r != null) {
				r.close();
			}
		}
		return result.toString();
	}

}
